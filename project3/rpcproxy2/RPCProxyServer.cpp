// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include "FIFOCache.h"
#include "LMUCache.h"
#include "LRUCache.h"
#include "RandomCache.h"
#include "gen-cpp/RPCProxy.h"
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TSimpleServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TBufferTransports.h>
#include <iostream>
#include <string>
#include <curl/curl.h>
#include <ctime>

using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;

using boost::shared_ptr;

using namespace  ::rpcproxy;

#define FIFO_CACHE "FIFO"
#define LRU_CACHE "LRU"
#define LMU_CACHE "LMU"
#define RANDOM_CACHE "RANDOM"

AbstractCache *cache = NULL;

class RPCProxyHandler : virtual public RPCProxyIf {
 public:
 int numberOfRequests;
 double totalTime;
 int cacheHits;
 
 RPCProxyHandler() {
    
	numberOfRequests = 0;
	totalTime = 0.0;
	cacheHits = 0;
  }

  void hello() {
    
    printf("hello\n");
  }

   static size_t WriteCallback(void *contents, size_t size, size_t nmemb, void *userp)
   {
	((std::string*)userp)->append((char*)contents, size * nmemb);
	return size * nmemb;
   }

   void fetchURLContent(std::string& _return, const std::string& url) 
   {
	//TODO: Input Validation for URL - NULL, Incorrect

	//struct timeval starttime;
	//struct timeval endtime;
	clock_t beginTime = clock(), endTime = clock();

	numberOfRequests++;


	if(cache != NULL)
        {
		//gettimeofday(&starttime, NULL);
		beginTime = clock();  
		string webcontent = cache->getFromCache(url);

		if(!webcontent.empty())
		{
			//gettimeofday(&endtime, NULL);
			cacheHits++;
			_return = webcontent;
		}
		else
		{
			CURL *curl;
			CURLcode res;
		 	std::string readBuffer;
	
		  	curl = curl_easy_init();
  
			if(curl) 
			{

				const char* urlLink = url.data();
		    		curl_easy_setopt(curl, CURLOPT_URL, urlLink);
    				curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, WriteCallback);
		    		curl_easy_setopt(curl, CURLOPT_WRITEDATA, &readBuffer);
    				res = curl_easy_perform(curl);
		    		curl_easy_cleanup(curl);

			}

			std::string out = readBuffer + std::string("\n");
	
			_return = out;

			if(_return.capacity() > cache->maxCacheSize)
			{
				cout << "\nWeb Content Size: " << _return.capacity() << " bytes";
				cout << "\nCache Size: " << cache->maxCacheSize << " bytes";
				cout << "\nRequested web content is not cached as its size exceeds cache size. \n";
				cout.flush();
			}
			else
			{
				cout << "\nInserting Web Content of size " << _return.capacity() << " bytes into the cache";
				cout << "\nRemaining cache capacity before insertion: " << cache->cacheSize << " bytes";
				
				cache->insertIntoCache(url, out);
				//gettimeofday(&endtime, NULL);
				//endTime = clock();
				cout << "\nRemaining cache capacity after Insertion: " << cache->cacheSize << " bytes";
				cout.flush();
			}
		}
		endTime = clock();

  	}

	//Calculate total Time;

	//double startTimeDouble = starttime.tv_sec;
	//double endTimeDouble = endtime.tv_sec;
	

	float timeTaken = float(endTime - beginTime) / CLOCKS_PER_SEC;
	totalTime += timeTaken;  

}

  void printServerStats() {
    // Your implementation goes here

    double averageTime = ((double)totalTime *1000)/numberOfRequests;
		
    cout << "\nCache Hits: " << cacheHits;
    cout << "\nNumber of Requests: " << numberOfRequests;
    cout << "\n Cache Hit Ratio: " << ((cacheHits*100)/numberOfRequests);
    cout << "\nAverage Time to Serve Requests: "  << averageTime << "milliseconds\n";
    cout.flush(); 	
  }

};

int main(int argc, char **argv) {

  
  int port = 9090;

 if(argc < 4)
 {
	printf("\nSyntax: %s <cache-type> <cache-size-in-KB> <port>", argv[0]);
	printf("\nOptions: cache-type - FIFO, RANDOM, LRU, LMU\n");
	exit(1);
 } 
 

  //TODO: Validate the Inputs
  const char* cacheType = argv[1];
  long cacheSize = atol(argv[2]);
  port = atoi(argv[3]);
	
  cout << "\nCache Type: " << cacheType;
  cout << "\nCache Size: " << (cacheSize * 1024) << " bytes";

  if(strcmp(cacheType, FIFO_CACHE) == 0)
  {
	cout << "\nFIFO Replacement Policy Selected for Cache\n";
	cout.flush(); 
  	cache = new FIFOCache();
  }
  else if(strcmp(cacheType, LRU_CACHE) == 0)
  {
	cout << "\nLRU Replacement Policy Selected for Cache\n";
	cout.flush();
	cache = new LRUCache();
  }
  else if(strcmp(cacheType, LMU_CACHE) == 0)
  {
	cout << "\nLMU Replacement Policy Selected for Cache\n";
	cout.flush();
        cache = new LMUCache();
  }
  else if(strcmp(cacheType, RANDOM_CACHE) == 0)
  {
	cout << "\nRandom Replacement Policy Selected for Cache\n";
	cout.flush();
	cache = new RandomCache();
  }
  else
  {
	cout <<"\nUnsupported Cache Type\n";
	cout.flush();
	//TODO: Check hw the client connection behaves here
	exit(1);
  }

  cache->setMaxCacheSize(cacheSize * 1024);
	
  //TODO: Modify Cache size according to input
  //TODO: Make Cache a member of RPCProxyHandler
  //TODO: Timestamps for cache 	
  cout.flush();

  boost::shared_ptr<RPCProxyHandler> handler(new RPCProxyHandler());
  boost::shared_ptr<TProcessor> processor(new RPCProxyProcessor(handler));
  boost::shared_ptr<TServerTransport> serverTransport(new TServerSocket(port));
  boost::shared_ptr<TTransportFactory> transportFactory(new TBufferedTransportFactory());
  boost::shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());

  TSimpleServer server(processor, serverTransport, transportFactory, protocolFactory);
  server.serve();
  return 0;
}

