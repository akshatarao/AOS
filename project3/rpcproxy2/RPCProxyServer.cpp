// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include "FIFOCache.h"
#include "LMUCache.h"
#include "LRUCache.h"
#include "RandomCache.h"
#include "gen-cpp/RPCProxy.h"
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TSimpleServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TBufferTransports.h>
#include <iostream>
#include <string>
#include <curl/curl.h>

using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;

using boost::shared_ptr;

using namespace  ::rpcproxy;

#define FIFO_CACHE "FIFO"
#define LRU_CACHE "LRU"
#define LMU_CACHE "LMU"
#define RANDOM_CACHE "RANDOM"

AbstractCache *cache = NULL;

class RPCProxyHandler : virtual public RPCProxyIf {
 public:
  RPCProxyHandler() {
    // Your initialization goes here
  }

  void hello() {
    // Your implementation goes here
    printf("hello\n");
  }

   static size_t WriteCallback(void *contents, size_t size, size_t nmemb, void *userp)
   {
	((std::string*)userp)->append((char*)contents, size * nmemb);
	return size * nmemb;
   }

   void fetchURLContent(std::string& _return, const std::string& url) 
   {
	//TODO: Input Validation for URL - NULL, Incorrect

	if(cache != NULL)
        {
		string webcontent = cache->getFromCache(url);

		if(!webcontent.empty())
		{
			_return = webcontent;
		}
		else
		{
			CURL *curl;
			CURLcode res;
		 	std::string readBuffer;
	
		  	curl = curl_easy_init();
  
			if(curl) 
			{

				const char* urlLink = url.data();
		    		curl_easy_setopt(curl, CURLOPT_URL, urlLink);
    				curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, WriteCallback);
		    		curl_easy_setopt(curl, CURLOPT_WRITEDATA, &readBuffer);
    				res = curl_easy_perform(curl);
		    		curl_easy_cleanup(curl);

			}

			std::string out = readBuffer + std::string("\n");
	
			_return = out;

			if(_return.capacity() > cache->maxCacheSize)
			{
				cout << "\nWeb Content Size: " << _return.capacity() << " bytes";
				cout << "\nCache Size: " << cache->maxCacheSize << " bytes";
				cout << "\nRequested web content is not cached as its size exceeds cache size. \n";
				cout.flush();
			}
			else
			{
				cout << "\nInserting Web Content of size " << _return.capacity() << " bytes into the cache";
				cout << "\nRemaining cache capacity before insertion: " << cache->cacheSize << " bytes";
				
				struct timeval startTime;
				cache->insertIntoCache(url, out);
				cout << "\nRemaining cache capacity after Insertion: " << cache->cacheSize << " bytes";
				cout.flush();
			}
		}
  	}
  }
};

int main(int argc, char **argv) {

  
  int port = 9090;

 if(argc < 4)
 {
	printf("\nSyntax: %s <cache-type> <cache-size-in-KB> <port>", argv[0]);
	printf("\nOptions: cache-type - FIFO, RANDOM, LRU, LMU\n");
	exit(1);
 } 
 

  //TODO: Validate the Inputs
  const char* cacheType = argv[1];
  long cacheSize = atol(argv[2]);
  port = atoi(argv[3]);
	
  cout << "\nCache Type: " << cacheType;
  cout << "\nCache Size: " << (cacheSize * 1024) << " bytes";

  if(strcmp(cacheType, FIFO_CACHE) == 0)
  {
	cout << "\nFIFO Replacement Policy Selected for Cache"; 
  	cache = new FIFOCache();
  }
  else if(strcmp(cacheType, LRU_CACHE) == 0)
  {
	cout << "\nLRU Replacement Policy Selected for Cache";
	cache = new LRUCache();
  }
  else if(strcmp(cacheType, LMU_CACHE) == 0)
  {
	cout << "\nLMU Replacement Policy Selected for Cache";
        cache = new LMUCache();
  }
  else if(strcmp(cacheType, RANDOM_CACHE) == 0)
  {
	cout << "\nRandom Replacement Policy Selected for Cache";
	cache = new RandomCache();
  }
  else
  {
	cout <<"\nUnsupported Cache Type";
	//TODO: Check hw the client connection behaves here
	exit(1);
  }

  cache->setMaxCacheSize(cacheSize * 1024);
	
  //TODO: Modify Cache size according to input
  //TODO: Make Cache a member of RPCProxyHandler
  //TODO: Timestamps for cache 	
  cout.flush();

  boost::shared_ptr<RPCProxyHandler> handler(new RPCProxyHandler());
  boost::shared_ptr<TProcessor> processor(new RPCProxyProcessor(handler));
  boost::shared_ptr<TServerTransport> serverTransport(new TServerSocket(port));
  boost::shared_ptr<TTransportFactory> transportFactory(new TBufferedTransportFactory());
  boost::shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());

  TSimpleServer server(processor, serverTransport, transportFactory, protocolFactory);
  server.serve();
  return 0;
}

